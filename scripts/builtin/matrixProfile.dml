#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

# ----------------------------------------------------------------------------
# References:
# Yan Zhu et al.. 2018.
#   Matrix Profile XI: SCRIMP++: Time Series Motif Discovery at Interactive Speeds.
#   2018 IEEE International Conference on Data Mining (ICDM), 2018, pp. 837-846.
#   DOI: 10.1109/ICDM.2018.00099.
# ----------------------------------------------------------------------------

# Builtin function that computes the MatrixProfile of a time series efficiently
# using the SCRIMP++ algorithm. 
#
# INPUT PARAMETERS:
# ----------------------------------------------------------------------------
# NAME                              TYPE      DEFAULT  MEANING
# ----------------------------------------------------------------------------
# ts                                Matrix    ---      Time series to profile
# window_size                       Integer   4        Sliding window size
# is_verbose                        Boolean   False    Print debug information
#
#
# RETURN VALUES
# ----------------------------------------------------------------------------
# NAME                              TYPE      DEFAULT  MEANING
# profile                           Matrix    ---      The computed matrix profile distances
# profile_index                     Matrix    ---      Indices of least distances


m_matrixProfile = function(Matrix[Double] ts, Integer window_size=4, Boolean is_verbose=FALSE)
  return(Matrix[Double] profile, Matrix[Double] profile_index)
{
  if (is_verbose)
    print ("##############################\n# MATRIXPROFILE SCRIPT ENTRY #\n##############################");

  n = length(ts);
  if (is_verbose)
    print("n: " + n + "\n")

  [mu,sig] = moving_avg(ts, n, window_size);

  # initialize
  infty = 1.7e308;
  profile_len = n-window_size+1;
  profile = matrix(infty, rows=1, cols=profile_len);
  profile_index = matrix(1, rows=1, cols=profile_len);

  profile[1,1] = 2
  profile_index[1,1] = 2


  # orders = RandPerm(m/4+1 : n-m+1) # randomize evaluation order
  # for k in Orders           //evaluating diagonals in random order
    # for i ← 1 to n-m+2-k
      # if i=1 do q ← DotProduct(T1,m, Tk,m)
      # else q ← q - ti-1 ti+k-2 + ti+m-1 ti+k+m-2      // see (2)
      # end if
      # d ← CalculateDistance(q, μi, σi , μi+k-1, σi+k-1) // see (1)
      # if d < Pido Pi← d, Ii← i+k-1 end if
      # if d < Pi+k-1 do Pi+k-1← d, Ii+k-1← i end if
    # end for
  # end for
  # return P, I
}

moving_avg = function(Matrix[Double] array, Integer n, Integer window_size)
  return(Matrix[Double] mu, Matrix[Double] sig)
{

  #  cdef Py_ssize_t i
  #  cdef Py_ssize_t n = a.shape[0]
  #  cdef Py_ssize_t ws = w
  #  cdef Py_ssize_t profile_len = n - w + 1
  #  cdef double[:] cumsum = np.empty(n, dtype='d')
  #  cdef double[:] sq_cumsum = np.empty(n, dtype='d')
  #  cdef double[:] sums = np.empty(profile_len, dtype='d')
  #  cdef double[:] sq_sums = np.empty(profile_len, dtype='d')
  #  cdef double[:] mu = np.empty(profile_len, dtype='d')
  #  cdef double[:] sig_sq = np.empty(profile_len, dtype='d')
  #  cdef double[:] sig = np.empty(profile_len, dtype='d')


  profile_len = n - window_size + 1;
  cumsum = matrix(0, rows=1, cols=n);
  sq_cumsum = matrix(0, rows=1, cols=n);
  sums = matrix(0, rows=1, cols=profile_len);
  sq_sums = matrix(0, rows=1, cols=profile_len);
  mu = matrix(0, rows=1, cols=profile_len);
  sig_sq = matrix(0, rows=1, cols=profile_len);
  sig = matrix(0, rows=1, cols=profile_len);

  cumsum[1,1] = array[1,1]
  sq_cumsum[1,1] = array[1,1] * array[1,1]

  mu[1,1] = 2;
  sig[1,1] = 2;

  #  for i in range(1, n):
    #  cumsum[i] = a[i] + cumsum[i - 1]
    #  sq_cumsum[i] = a[i] * a[i] + sq_cumsum[i - 1]

  #  sums[0] = cumsum[w - 1]
  #  sq_sums[0] = sq_cumsum[w - 1]
  #  for i in range(n - w):
    #  sums[i + 1] = cumsum[w + i] - cumsum[i]
    #  sq_sums[i + 1] = sq_cumsum[w + i] - sq_cumsum[i]

  #  for i in range(profile_len):
    #  mu[i] = sums[i] / w
    #  sig_sq[i] = sq_sums[i] / w - mu[i] * mu[i]

    #  if sig_sq[i] < 0:
      #  sig[i] = 0
    #  else:
      #  sig[i] = sqrt(sig_sq[i])
}
