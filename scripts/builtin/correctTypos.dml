#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

# ----------------------------------------------------------------------------
# References:
# Fred J. Damerau. 1964. 
#   A technique for computer detection and correction of spelling errors. 
#   Commun. ACM 7, 3 (March 1964), 171â€“176. 
#   DOI:https://doi.org/10.1145/363958.363994
# ----------------------------------------------------------------------------

# Builtin function that implements the k-Means clustering algorithm
#
# INPUT PARAMETERS:
# ----------------------------------------------------------------------------
# NAME                              TYPE      DEFAULT  MEANING
# ----------------------------------------------------------------------------
# X                                 Double    ---      The input Matrix to do KMeans on.
# k                                 Int       ---      Number of centroids
# runs                              Int       10       Number of runs (with different initial centroids)
# max_iter                          Int       1000     Maximum number of iterations per run
# eps                               Double    0.000001 Tolerance (epsilon) for WCSS change ratio
# is_verbose                        Boolean   FALSE    do not print per-iteration stats
# avg_sample_size_per_centroid      Int       50       Average number of records per centroid in data samples
# seed                              Int       -1       The seed used for initial sampling. If set to -1 random seeds are selected. 
#
#
# RETURN VALUES
# ----------------------------------------------------------------------------
# NAME     TYPE      DEFAULT  MEANING
# ----------------------------------------------------------------------------
# Y        String    "Y.mtx"  The mapping of records to centroids
# C        String    "C.mtx"  The output matrix with the centroids
# ----------------------------------------------------------------------------


s_correctTypos = function(Frame[String] strings, Boolean decapitalize, Boolean correct, 
    Boolean is_verbose)
  return (Frame[String] Y)
{
  if(is_verbose)
    print ("BEGIN CORRECT-TYPOS SCRIPT");

  Y = strings;
  num_strings = length(strings);

  if(is_verbose)
    print("num strings: " + num_strings + "\n")
    # print(toString(strings));

  strings = map(strings, "s -> s.toLowerCase()");
  # print(toString(strings));
  # print(toString(lengths)); # DONT COMMENT THIS OUT

  # build dictionary
  current_string = as.scalar(strings[1]);
  dict = cbind(as.frame(current_string), as.frame(1));
  for (i in 2:num_strings) {
    current_string = as.scalar(strings[i]);
    dict = insertOrIncrement(current_string, dict);
  }
  strings = dict[,1];
  frequencies = dict[,2];
  lengths = as.matrix(map(strings, "s -> s.length()"));
  num_different_strings = nrow(strings);

  if (is_verbose) {
    print("dict:" )
    print(toString(dict));
    print("lengths:")
    print(toString(lengths))
  }

  # generate ascii matrix
  max_len = max(lengths);
  if (is_verbose) {
    print("max_len: " + max_len + "\n");
  }
  ascii_matrix = matrix(0, rows = max_len, cols = num_different_strings)
  for (i in 1:num_different_strings) {
    for (j in 1:as.scalar(lengths[i, 1])) {
      tmp = as.matrix(map(strings[i,], "s -> UtilFunctions.getAsciiAtIdx(s, " + j + ")"));
      ascii_matrix[j, i] = tmp[1, 1];
    }
  }
  if (is_verbose) {
    print("ascii_matrix: ")
    print(toString(ascii_matrix));
  }

  # TODO: create upper triangular matrix with distances

  A = ascii_matrix[1:as.scalar(lengths[1,1]), 1];
  B = ascii_matrix[1:as.scalar(lengths[2,1]), 2];

  damerauLevenshteinDistanceBound(A, B, max(length(A), length(B)), is_verbose);
}


insertOrIncrement = function(String str, Frame[Unknown] dict)
  return(Frame[Unknown] dict)
{
  i = 1;
  ret = FALSE;
  break = FALSE;
  while (i <= nrow(dict) & !break) {
    # print(as.scalar(dict[i, 1]) + str);
    # print(toString(as.scalar(dict[i, 1])) + str);
    if (as.scalar(dict[i, 1]) == str) {
      value = as.integer(as.scalar(dict[i, 2]) + 1);
      dict[i, 2] = value;
      # print("Incrementing to " + value);
      contains = TRUE;
      break = TRUE;
    }
    i += 1;
  }
  if (!break) {
    # print("Adding row");
    dict = rbind(dict, cbind(as.frame(str), as.frame(1)));
  }
}


damerauLevenshteinDistanceBound = function(matrix[double] A, matrix[double] B, double bound, Boolean is_verbose) 
  return(double dl_distance) {

  dl_matrix = matrix(0, rows = length(A) + 1, cols = length(B) + 1);
  dl_matrix[length(A) + 1, length(B) + 1] = -1;

  for (j in 2:length(B) + 1) {
    dl_matrix[1, j] = j - 1;
  }

  dl_matrix[2, 1] = 1;

  for (j in 2:length(B) + 1) {
    if (as.scalar(A[1]) == as.scalar(B[j - 1])) {
      cost = 0;
    } else {
      cost = 1;
    }
    dl_matrix[2, j] = min(min(
      dl_matrix[2, j - 1] + 1, 
      dl_matrix[1, j] + 1),
      dl_matrix[1, j - 1] + cost);
  }

  i = 2;
  break_condition = FALSE;
  while (i < length(A) + 1 & !break_condition) {
    i += 1;

    dl_matrix[i, 1] = i - 1;

    if (as.scalar(A[i - 1]) == as.scalar(B[1])) {
      cost = 0;
    } else {
      cost = 1;
    }
    dl_matrix[i, 2] = min(min(
      dl_matrix[i - 1, 2] + 1, 
      dl_matrix[i, 1] + 1),
      dl_matrix[i - 1, 1] + cost);

    for (j in 3:length(B) + 1) {
      if (as.scalar(A[i - 1]) == as.scalar(B[j - 1])) {
        cost = 0;
      } else {
        cost = 1;
      }
      if (as.scalar(A[i - 1]) == as.scalar(B[j - 2]) & as.scalar(A[i - 2]) == as.scalar(B[j - 1])) {
        dl_matrix[i, j] = min(min(
          dl_matrix[i, j - 1] + 1, 
          dl_matrix[i - 1, j] + 1), min(
          dl_matrix[i - 1, j - 1] + cost,
          dl_matrix[i - 2, j - 2] +  1));
      } else {
        dl_matrix[i, j] = min(min(
          dl_matrix[i, j - 1] + 1, 
          dl_matrix[i - 1, j] + 1),
          dl_matrix[i - 1, j - 1] + cost);   
      }
    }

    if( min(dl_matrix[i - 1, ]) > bound & min(dl_matrix[i, ]) > bound) {
      break_condition = TRUE;
    }
  }

  if (is_verbose){
    print("dl distance matrix:")
    print(toString(dl_matrix));
  }

  dl_distance = as.scalar(dl_matrix[length(A) + 1, length(B) + 1]);
}
