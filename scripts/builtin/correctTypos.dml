#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

# ----------------------------------------------------------------------------
# References:
# Fred J. Damerau. 1964. 
#   A technique for computer detection and correction of spelling errors. 
#   Commun. ACM 7, 3 (March 1964), 171â€“176. 
#   DOI:https://doi.org/10.1145/363958.363994
# ----------------------------------------------------------------------------

# Builtin function that implements the k-Means clustering algorithm
#
# INPUT PARAMETERS:
# ----------------------------------------------------------------------------
# NAME                              TYPE      DEFAULT  MEANING
# ----------------------------------------------------------------------------
# X                                 Double    ---      The input Matrix to do KMeans on.
# k                                 Int       ---      Number of centroids
# runs                              Int       10       Number of runs (with different initial centroids)
# max_iter                          Int       1000     Maximum number of iterations per run
# eps                               Double    0.000001 Tolerance (epsilon) for WCSS change ratio
# is_verbose                        Boolean   FALSE    do not print per-iteration stats
# avg_sample_size_per_centroid      Int       50       Average number of records per centroid in data samples
# seed                              Int       -1       The seed used for initial sampling. If set to -1 random seeds are selected. 
#
#
# RETURN VALUES
# ----------------------------------------------------------------------------
# NAME     TYPE      DEFAULT  MEANING
# ----------------------------------------------------------------------------
# Y        String    "Y.mtx"  The mapping of records to centroids
# C        String    "C.mtx"  The output matrix with the centroids
# ----------------------------------------------------------------------------


s_correctTypos = function(Frame[String] strings, Boolean decapitalize, Boolean correct, 
    Boolean is_verbose)
  return (Frame[String] Y)
{
  if(is_verbose)
    print ("BEGIN CORRECT-TYPOS SCRIPT");

  Y = strings;

  num_strings = length(strings);

  if(is_verbose)
    print("num strings: " + num_strings)

  print(toString(strings));

  lc = map(strings, "s -> s.toLowerCase()"); # works
  lengths = map(strings, "s -> s.length()"); # works
  # subs = map(strings, "s -> s[2]"); # doesnt work
  subs = map(strings, "s -> s.substring(0,2)"); # works

  print(toString(lc));
  print(toString(lengths));
  print(toString(subs));

  A = matrix("1 3 2 4 5 4 3 6 2 5 2 4 5 3 6 3", rows = 16, cols = 1);
  B = matrix("1 2 3 4 5 2 3 2 7 5 2 4 6 3 6", rows = 15, cols = 1);

  damerauLevenshteinDistanceBound(A, B, max(length(A), length(B)), is_verbose);
  # str = "hello world!";

  # print(sc);
  # print(s.charAt(2));
  # c = as.character(s);
  # print(c);
  #m = matrix(s, rows=2, cols=6);
  #print(toString(m));

  # if(!decapitalize)
    # if(is_verbose)
      # print("Only decapitalization currently supported")
}


damerauLevenshteinDistanceBound = function(matrix[double] A, matrix[double] B, double bound, Boolean is_verbose) 
  return(double dl_distance) {

  dl_matrix = matrix(0, rows = length(A) + 1, cols = length(B) + 1);
  dl_matrix[length(A) + 1, length(B) + 1] = -1;

  for (j in 2:length(B) + 1) {
    dl_matrix[1, j] = j - 1;
  }

  dl_matrix[2, 1] = 1;

  for (j in 2:length(B) + 1) {
    if (as.scalar(A[1]) == as.scalar(B[j - 1])) {
      cost = 0;
    } else {
      cost = 1;
    }
    dl_matrix[2, j] = min(min(
      dl_matrix[2, j - 1] + 1, 
      dl_matrix[1, j] + 1),
      dl_matrix[1, j - 1] + cost);
  }

  i = 2;
  break_condition = FALSE;
  while (i < length(A) + 1 & !break_condition) {
    i += 1;

    dl_matrix[i, 1] = i - 1;

    if (as.scalar(A[i - 1]) == as.scalar(B[1])) {
      cost = 0;
    } else {
      cost = 1;
    }
    dl_matrix[i, 2] = min(min(
      dl_matrix[i - 1, 2] + 1, 
      dl_matrix[i, 1] + 1),
      dl_matrix[i - 1, 1] + cost);

    for (j in 3:length(B) + 1) {
      if (as.scalar(A[i - 1]) == as.scalar(B[j - 1])) {
        cost = 0;
      } else {
        cost = 1;
      }
      if (as.scalar(A[i - 1]) == as.scalar(B[j - 2]) & as.scalar(A[i - 2]) == as.scalar(B[j - 1])) {
        dl_matrix[i, j] = min(min(
          dl_matrix[i, j - 1] + 1, 
          dl_matrix[i - 1, j] + 1), min(
          dl_matrix[i - 1, j - 1] + cost,
          dl_matrix[i - 2, j - 2] +  1));
      } else {
        dl_matrix[i, j] = min(min(
          dl_matrix[i, j - 1] + 1, 
          dl_matrix[i - 1, j] + 1),
          dl_matrix[i - 1, j - 1] + cost);   
      }
    }

    if( min(dl_matrix[i - 1, ]) > bound & min(dl_matrix[i, ]) > bound) {
      break_condition = TRUE;
    }
  }

  if (is_verbose){
    print(toString(dl_matrix));
  }

  dl_distance = as.scalar(dl_matrix[length(A) + 1, length(B) + 1]);
}
